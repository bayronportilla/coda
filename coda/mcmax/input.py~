from coda.mcmax.header import *

@dataclass
class File:
    x:float
    y:float
    name:str

    def calculate_mass(self):
        x,y=(self.x*u.au).to(u.cm).value,self.y
        dust_mass=(2*np.pi*simps(x*y,x)*u.g).to(u.Msun)
        return dust_mass

    def plot(self):
        x,y=self.x,self.y
        fig,ax=plt.subplots(1,1)
        ax.plot(x,y,'.')
        ax.set(xscale="log",yscale="log")
        plt.show()

    def rescale_mass(self,k,rmin=None):

        '''
        Rescale density profile by a factor of k.

        Parameters:
            k (float): rescaling factor.
            rmin (float): to only rescale the points r>=rmin or r<=rmin.
            If rmin is None, rescale the entire profile.
        '''

        x,y=(self.x*u.au).to(u.cm).value,self.y
        Mold=(2*np.pi*simps(x*y,x)*u.g).to(u.Msun)
        if rmin is None: ynew=k*y
        if rmin is not None:
            ynew=[]
            ynew+=[1*y[i] for i in range (len(self.x)) if self.x[i]<=rmin]
            ynew+=[k*y[i] for i in range (len(self.x)) if self.x[i]>rmin]

        Mnew=(2*np.pi*simps(x*ynew,x)*u.g).to(u.Msun)

        ''' Print info '''
        print("\nInitial mass:",Mold)
        print("Rescaled mass:",Mnew)
        #print("Mnew/Mold: %.3f"%(Mnew/Mold))

        ''' Create rescaled mass file '''
        f=open(self.name+".rescaled","w")
        for i,j in zip(self.x,ynew):
            f.write("%.15e %.15e\n"%(i,j))
        f.close()

        return None

    def plot_MCSpec(self,unit=None):
        if not unit:
            x,y=self.x,self.y
            fig,ax=plt.subplots(1,1)
            ax.plot(x,y)
            ax.set(xscale="log",yscale="log")
            plt.show()


def get_size_distribution(model):
    ''' '''

    ''' Read file names '''
    filenames=[]
    folder=model+"/Particles/"
    for filename in os.listdir(folder):
        if fnmatch.fnmatch(filename,('*.fits.gz')):
            filenames.append(filename)

    psize=np.zeros((len(filenames),3))
    i=0
    for file in filenames:
        hdulist=fits.open(model+'/Particles/'+file)
        hdu=hdulist[0]
        hdr=hdu.header
        a=hdr['A1']
        amin=hdr["R_MIN"]
        amax=hdr["R_MAX"]
        psize[i]=[a,amin,amax]
        i+=1
    return psize


def upload_file(file):

    '''
    Create a File object from a two-column file
    '''

    data=np.loadtxt(file)
    x=np.reshape(data[:,0:1],data.shape[0])
    y=np.reshape(data[:,1:2],data.shape[0])
    name=file

    return File(x,y,name)


def density_profile(Rin,Rout,Mdust,
                    Rtap=None,epsilon=None,gamma=None):
    k=10
    N_points=2**k+1
    Rin,Rout,Mdust=Rin*u.au,Rout*u.au,Mdust*u.Msun
    rarray=np.linspace(Rin,Rout,N_points)
    Rtap=Rtap*u.au if Rtap is not None else 100*u.au
    if epsilon is None:epsilon=1.0
    if gamma is None:gamma=1.0
    def integrand(x):
        return x*(Rtap.value/x)**epsilon*np.exp(-(x/Rtap.value)**(2-gamma))
    Sigma0=(Mdust/(2*np.pi*quad(integrand,Rin.value,Rout.value)[0]*u.au**2)).to(u.g/u.cm**2)
    Sigma=[(Sigma0.value*(Rtap/i)**epsilon*np.exp(-(i/Rtap)**(2-gamma))).value for i in rarray]
    file=open("density.dat","w")
    for i,j in zip(rarray,Sigma):
        file.write("%.15e %.15e\n"%(i.value,j))
    file.close()
    return None


def convert_comp(fc,porosity,qtype) :
    '''
    Convert grain composition from the MCMax3D standard to the ProDiMo standard
    and vice-versa.

    Parameters
    ----------
        fc: fraction of carbon.

        porosity: the fraction of vaccum the grain is made of. If the amount of
        vacuum is say 10%, then you must enter porosity=0.1.

        qtype: The type of the input quantities. It can be either 'mcmax' or
        'prodimo'. If qtype='mcmax', then the routine will return the correspondent
        ProDiMo quantities. If qtype='prodimo', then the routine will return the
        correspondent MCMax3D quantities.
    '''

    ''' Bulk constants. Do not touch them unless the hard-coded quantities in
    MCMax3D have changed. '''
    rho_c=1.8   # g cm^-2
    rho_si=3.01 # g cm^-2

    #From MCMax3D to ProDiMo
    if qtype=="mcmax":
        fcM=fc
        ''' Derived quantities '''
        fsiM=1-fcM
        fcV=(1-rho_c/rho_si*(1-fcM**(-1)))**(-1)
        fsiV=1-fcV

        ''' Converting to ProDiMo quantities '''
        FsiV=(1-porosity)*(fcV/fsiV+1)**(-1)
        FcV=(fcV/fsiV)*FsiV

        print("\nThe correspondent ProDiMo quantities are:")
        print("FsiV=%.15f"%(FsiV))
        print("FcV=%.15f"%(FcV))
        print("FsiV+FcV+porosity=",FsiV+FcV+porosity)

    #From ProDiMo to MCMax3D
    elif qtype=="prodimo":
        FcV=fc
        ''' Derived quantities '''
        FsiV=1-FcV-porosity

        ''' Converting to MCMax3D quantities '''
        fsiV=(1+FcV/FsiV)**(-1)
        fcV=1-fsiV
        fcM=(1-(rho_si/rho_c)*(1-fcV**-1))**(-1)
        fsiM=1-fcM

        print("\nThe correspondent MCMax3D quantities are:")
        print("fcM=%.15f"%(fcM))
        print("fsiM=%.15f"%(fsiM))
        print("fsiM+fcM=%.15f"%(fsiM+fcM))

    return None


def convert_density_file(fobj,stop_after_init=None,psize=None,p=None,rhog=None,
    segfile=None,visual=None,mcmax_like=None,interpol=None):
    '''
    Convert a standard MCMax3D surface density profile
    into a ProDiMo 1D input sdfile. As an argument, it receives
    an object of the class File with the following
    characteristics:

    - fobj.x in au
    - fobj.y in g cm^-2

    The length of the r_array will determine the
    resolution of the ProDiMo model. Choose it wisely!
    '''

    @dataclass
    class GridPoint:
        r:float
        theta:float
        phi:float
        dr:float
        dtheta:float
        dphi:float
        comp:float

        def dV(self):
            # Units: cm^3
            value=self.r**2*np.sin(self.theta)*self.dr*self.dtheta*self.dphi
            return value

        def dz(self):
            # Units: cm
            value=self.r*self.dtheta
            return value

        def zsph(self):
            # Units: cm
            value=self.r*np.cos(self.theta)
            return value

        def rsph(self):
            ### Units: cm
            value=self.r*np.sin(self.theta)
            return value

        def Mi(self,aindex):
            # Units: g
            rho_i=self.comp[aindex]
            M_i=rho_i*self.dV()
            return M_i

        def Mtot(self):
            # Units: g
            M_tot=0.0
            for i in range(len(self.comp)):
                M_tot+=self.Mi(i)
            return M_tot

        def Sigmai(self,aindex):
            # Units: g cm^-2
            rho_i=self.comp[aindex]
            value=rho_i*self.dz()
            return value


    @dataclass
    class GridPointProdimo:
        r:float
        z:float
        comp:float
        def comps(self):
            # Units: cm^3
            #value=self.r**2*np.sin(self.theta)*self.dr*self.dtheta*self.dphi
            value=0
            return value


    if mcmax_like:
        print("Retrieving the exact MCMax3D profile")
        model='/data/users/bportilla/runs/final_runs/recalibration_ppd/run130/'
        #model='/data/users/bportilla/runs/final_runs/recalibration_ppd/run128/'

        ''' Reading particle size array '''
        ai_array=psize[:,0] # microns

        def func_fsize(zoneID):
            ''' Working with zones'''
            ### Import data
            hdu_1=fits.open(model+"output/Zone000%d.fits.gz"%(zoneID))

            ### Composition matrix
            ### C[3]:pmid(rad), C[4]:tmid(rad), C[5]:rmid(au)
            C=hdu_1[6].data

            ### Center coordinates
            rmidAU=hdu_1[0].data[0,0,0,:]
            rmid=(rmidAU*u.au).to(u.cm).value # cm
            tmid=hdu_1[0].data[1,0,:,0]       # rad
            pmid=hdu_1[0].data[2,:,0,0]       # rad

            ### Borders
            rlim=hdu_1[1].data   # cm
            tlim=hdu_1[2].data   # rad
            plim=hdu_1[3].data   # rad


            ### Declare an empty array to host GridPoint instances. This
            ### is only needed to compute the total dust mass.
            GParray=[]
            GPSph_array=[]

            # Declare fsize matrix full of zeros.
            fsize=np.zeros((len(ai_array),len(rmid)))

            ### Declare Mcolumn arrays
            #Mcolumn_array=np.zeros(len(rmid))

            #print(len(tmid))
            #print(tmid[int(len(tmid)*0.5)])
            #sys.exit()
            ### Declare matrix needed for interpolation
            #MGP=np.zeros((len(rmid),int(len(tmid)*0.5)))
            MGP=np.empty((int(len(tmid)*0.5),len(rmid)),dtype='object')

            # The big loop
            for i in range(C.shape[5]): # Along r
                dr=rlim[i+1]-rlim[i]
                #Mcolumn=0.0
                for j in range(C.shape[4]): # Along theta
                    dt=tlim[j+1]-tlim[j]
                    for k in range(C.shape[3]): # Along phi
                        dp=plim[k+1]-plim[k]
                        comp=C[0,:,0,k,j,i] # g cm^-3
                        GP=GridPoint(rmid[i],tmid[j],pmid[k],dr,dt,dp,comp)
                        GParray.append(GP)
                        if k==0.0 and j<len(tmid)*0.5:
                            MGP[j,i]=GP
                            #Mcolumn+=GP.Mtot()
                            """
                            for l in range(len(ai_array)):
                                #fsize[l,i]+=GP.Mi(l)
                                fsize[l,i]+=GP.Sigmai(l)
                            """
                #Mcolumn_array[i]=Mcolumn

            """
            # Dividing by Mcolumn
            for i in range(fsize.shape[1]):
                for l in range(fsize.shape[0]):
                    fsize[l,i]=fsize[l,i]/Mcolumn_array[i]
            """

            return fsize,rmidAU,MGP

        ### Concatenate fsizes and rmidAU
        fsize_1,rmidAU_1,MGP_1=func_fsize(1)[0],func_fsize(1)[1],func_fsize(1)[2]
        fsize_2,rmidAU_2,MGP_2=func_fsize(2)[0],func_fsize(2)[1],func_fsize(2)[2]
        MGP=np.concatenate((MGP_1,MGP_2),axis=1)
        #MGP=MGP_1
        fsize_tmp=np.concatenate((fsize_1,fsize_2),axis=1)
        r_array=np.concatenate((rmidAU_1,rmidAU_2))

        ### Declaring and filling in C matrix for MCMax3D. It only stores
        ### the density.
        #C=np.empty((psize.shape[0],MGP.shape[0],MGP.shape[1]),dtype='object')
        C=np.zeros((psize.shape[0],MGP.shape[0],MGP.shape[1]))
        for k in range(C.shape[0]): # Over grain size
            for i in range(C.shape[1]): # Over theta
                for j in range(C.shape[2]): # Over radius
                    C[k,i,j]=MGP[i,j].comp[k]


        ### Creating matrix for ProDiMo grid points
        model=read_prodimo()
        r_array_p=np.reshape(model.x[:,0:1],model.x.shape[0]) # au
        z_matrix=model.z   # (au) len(r)*len(z)
        print(MGP.shape)
        print(z_matrix.shape)

        ### Declaring and filling in C matrix for ProDiMo. Composition is
        ### initialised to None.
        #C_prodimo=np.empty((psize.shape[0],z_matrix.shape[1],z_matrix.shape[0]),dtype='object')
        C_prodimo=np.empty((psize.shape[0],z_matrix.shape[1],int(z_matrix.shape[0]*0.5)),dtype='object')
        for k in range(C_prodimo.shape[0]): # Over grain size
            for i in range(C_prodimo.shape[1]): # Over z
            #for i in range(C_prodimo.shape[1]-1,0,-1): # Over z
                for j in range(C_prodimo.shape[2]): # Over radius
                    GP_prodimo=GridPointProdimo(r_array_p[j],z_matrix[j,i],None)
                    C_prodimo[k,i,j]=GP_prodimo
        """"
        print("MCMax limits:")
        print("rmin,zmax",(MGP[0,0].rsph()*u.cm).to(u.au),(MGP[0,0].zsph()*u.cm).to(u.au))
        print("rmin,zmin",(MGP[-1,0].rsph()*u.cm).to(u.au),(MGP[-1,0].zsph()*u.cm).to(u.au))
        print("rmax,zmax",(MGP[0,-1].rsph()*u.cm).to(u.au),(MGP[0,-1].zsph()*u.cm).to(u.au))
        print("rmax,zmin",(MGP[-1,-1].rsph()*u.cm).to(u.au),(MGP[-1,-1].zsph()*u.cm).to(u.au))
        """
        #sys.exit()
        ### Start 2D interpolation
        ### Sampling MCMax3D info into 1D arrays.
        #print(z_matrix)
        #print((MGP[0,0].zsph()*u.cm).to(u.au))
        #print((MGP[-1,0].zsph()*u.cm).to(u.au))
        #sys.exit()
        #for k in range(C.shape[0]):
        for k in range(psize.shape[0]):
            #if k==7:
            rsph_array=[]
            zsph_array=[]
            csph_array=[]
            for j in range(MGP.shape[1]): # Over radius
                for i in range(MGP.shape[0]): # Over theta
                    rsph_array.append((MGP[i,j].rsph()*u.cm).to(u.au).value)
                    zsph_array.append((MGP[i,j].zsph()*u.cm).to(u.au).value)
                    #csph_array.append(C[k,i,j])
                    csph_array.append(np.log10(C[k,i,j]))
                    #csph_array.append(MGP[i,j].comp[k])
                    #csph_array.append(1e-15)
            #print(rsph_array)
            #print(zsph_array)
            #print(csph_array)
            #f=interp2d(rsph_array,zsph_array,csph_array,
            #            kind='linear',bounds_error=False)
            f=Rbf(rsph_array,zsph_array,csph_array,
                        function='linear')

            ### Interpolate into ProDiMo grid and filling in
            ### composition for C_prodimo instances
            rmin,rmax=np.log10(0.0036),np.log10(37.106)
            zmin,zmax=np.log10(2e-6),np.log10(36.955)
            for i in range(C_prodimo.shape[1]): # Over z
                for j in range(C_prodimo.shape[2]): # Over radius
                    rprodimo=C_prodimo[k,i,j].r
                    zprodimo=C_prodimo[k,i,j].z
                    #if zmin<zprodimo<zmax and rmin<rprodimo<rmax:
                    C_prodimo[k,i,j].comp=f(rprodimo,zprodimo)
    return C_prodimo

"""
        ### Calculating total mass contained in ProDiMo grid.
        S_prodimo=np.zeros((C_prodimo.shape[0],C_prodimo.shape[2]))
        for k in range(C_prodimo.shape[0]):
            for j in range(C_prodimo.shape[2]):
                rho_vals,z_vals=[],[]
                for i in range(C_prodimo.shape[1]):
                    rho_vals.append(C_prodimo[k,i,j].comp)
                    z_vals.append((C_prodimo[k,i,j].z*u.au).to(u.cm).value)
                S_prodimo[k,j]=simps(rho_vals,z_vals)

        print(S_prodimo[-1])






        sys.exit()


        ''' Interpolate density profile '''
        x,y=fobj.x,fobj.y
        g2d=100.0
        g2d_array=g2d*np.ones(len(r_array))
        cs=CubicSpline(x,y)
        y_array=cs(r_array)

        ### Multiplying by 1D surface density
        #fsize=fsize_tmp*y_array
        fsize=fsize_tmp

        if visual:
            ''' Quick plot to check things out '''
            fig,(ax1,ax2)=plt.subplots(1,2,figsize=(15,5))
            for i in range(psize.shape[0]):
                if i==0:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                elif i==psize.shape[0]-1:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                else:
                    if i%10==0:
                        ax1.plot(r_array,fsize[i])

            density_reconstructed=np.zeros(fsize.shape[1])
            for j in range(fsize.shape[1]):
                density_reconstructed[j]=np.sum(np.reshape(fsize[:,j:j+1],fsize.shape[0]))

            ax2.plot(fobj.x,fobj.y,label='original')
            ax2.plot(r_array,density_reconstructed,'.',label='reconstructed')

            ax1.set_yscale("log")
            ax2.set_yscale("log")
            ax1.legend()
            ax2.legend()
            plt.show()


        ''' Convert to prodimopy units '''
        ai_array=(ai_array*u.micron).to(u.cm)
        r_array=(r_array*u.au).to(u.cm)


        ''' Calling prodimopy '''
        write("sdprofile.in",r_array.value,y_array*g2d,g2d_array,ai_array.value,fsize)



        file=open("f2.dat","w")
        for i in range(fsize.shape[1]):
            file.write("%.15e %.15e\n"%(r_array[i],fsize[0,i]))
        file.close()
        sys.exit()




        ''' Compute total mass '''
        Mdisk=0.0
        for i in range(len(GParray)):
            Mdisk+=GParray[i].Mtot()
        print(Mdisk)





        ''' Read radial grid needed for interpolation '''

        hdu=fits.open(model+"output/Zone0001.fits")
        grid=hdu[0].data[0,0,0,:]
        print(grid)
        print(grid.shape)
        sys.exit()


        r1=np.loadtxt(model+"output/radgrid0001.dat")
        r2=np.loadtxt(model+"output/radgrid0002.dat")
        r_array=np.concatenate((r1,r2))


        ''' Reading particle size array '''
        ai_array=psize[:,0]

        ''' Finding fsize matrix '''
        hdu_1=fits.open(model+"output/Zone0001.fits")
        hdu_2=fits.open(model+"output/Zone0002.fits.gz")

        ### Reading radial grid
        r1=hdu_1[0].data[0,0,0,:]
        r2=hdu_2[0].data[0,0,0,:]
        r_array=np.concatenate((r1,r2))

        ''' Interpolate density profile '''
        x,y=fobj.x,fobj.y
        g2d=100.0
        g2d_array=g2d*np.ones(len(r_array))
        cs=CubicSpline(x,y)
        y_array=cs(r_array)

        ### Reading composition
        M1=hdu_1[6].data
        M2=hdu_2[6].data

        #print(M1[:,0,:,0,:,0].max())
        #print(M1.shape[4])

        val=0
        for i in range(M1.shape[4]):
            val+=M1[:,0,:,0,i,0]
        print(val)
        ### integrating along theta values
        M1=np.sum(M1[:,:,:,:,:,:],axis=4)
        M2=np.sum(M2[:,:,:,:,:,:],axis=4)

        print(M1[:,0,:,-1,0])

        sys.exit()
        ### Extract arrays with phi=0.0
        M1=M1[:,:,:,0,:]
        M2=M2[:,:,:,0,:]


        ### Creating fsize array full of zeros for each zone
        m1=M1.shape[1]
        m2=M2.shape[1]
        n1=M1.shape[3]
        n2=M2.shape[3]
        fsize_1=np.zeros((m1,n1))
        fsize_2=np.zeros((m2,n2))

        ### Computing relative abundances and filling in the fsize matrix in each zone
        for j in range(n1):
            abun_tot=np.sum(M1[:,:,:,j])
            for i in range(m1):
                abun_i=M1[:,i,:,j]
                abun_rel=abun_i/abun_tot
                fsize_1[i,j]=abun_rel
        for j in range(n2):
            abun_tot=np.sum(M2[:,:,:,j])
            for i in range(m2):
                abun_i=M2[:,i,:,j]
                abun_rel=abun_i/abun_tot
                fsize_2[i,j]=abun_rel

        ### Concatenate fsize matrices
        fsize_tmp=np.concatenate((fsize_1,fsize_2),axis=1)

        ### Multypling by surface density
        fsize=fsize_tmp*y_array



        if visual:
            ''' Quick plot to check things out '''
            fig,(ax1,ax2)=plt.subplots(1,2,figsize=(15,5))
            for i in range(psize.shape[0]):
                if i==0:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                elif i==psize.shape[0]-1:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                else:
                    if i%10==0:
                        #ax1.plot(r_array,fsize[i],label="%.3f micron"%(psize[i,0]))
                        ax1.plot(r_array,fsize[i])

            density_reconstructed=np.zeros(fsize.shape[1])
            for j in range(fsize.shape[1]):
                density_reconstructed[j]=np.sum(np.reshape(fsize[:,j:j+1],fsize.shape[0]))

            ax2.plot(fobj.x,fobj.y,label='original')
            ax2.plot(r_array,density_reconstructed,'.',label='reconstructed')

            ax1.set_yscale("log")
            ax2.set_yscale("log")
            ax1.legend()
            ax2.legend()
            plt.show()
"""
"""

    if interpol:
        print("Interpolating quantities to ProDiMo grid")

        model=read_prodimo()
        r_array_p=np.reshape(model.x[:,0:1],model.x.shape[0])
        z_matrix=model.z

        # Declare an empty array to host GridPointCyl instances.
        GPCyl_array=[]


        sys.exit()
        for i in range(z_matrix.shape[0]): # Over radius
            for j in range(z_matrix.shape[1]): # Over height
                GPCyl=GridPointCyl(r_array_p[i],z_matrix[i,j])
                GPCyl_array.append(GPCyl)

        print(len(GPCyl_array))


        sys.exit()
        model='/data/users/bportilla/runs/final_runs/recalibration_ppd/run129/'
        #model='/data/users/bportilla/runs/final_runs/recalibration_ppd/run128/'

        ''' Reading particle size array '''
        ai_array=psize[:,0] # microns

        def func_fsize(zoneID):
            ''' Working with zones'''
            # Import data
            hdu_1=fits.open(model+"output/Zone000%d.fits.gz"%(zoneID))

            # Composition matrix
            # C[3]:pmid(rad), C[4]:tmid(rad), C[5]:rmid(au)
            C=hdu_1[6].data

            # Center coordinates
            rmidAU=hdu_1[0].data[0,0,0,:]
            rmid=(rmidAU*u.au).to(u.cm).value
            tmid=hdu_1[0].data[1,0,:,0]
            pmid=hdu_1[0].data[2,:,0,0]

            # Borders
            rlim=hdu_1[1].data
            tlim=hdu_1[2].data
            plim=hdu_1[3].data

            # Declare an empty array to host GridPoint instances.
            # This is only needed to compute the total dust mass.
            GParray=[]

            # Declare fsize matrix full of zeros.
            fsize=np.zeros((len(ai_array),len(rmid)))

            ### Declare Mcolumn arrays
            #Mcolumn_array=np.zeros(len(rmid))

            # The big loop
            for i in range(C.shape[5]): # Along r
                dr=rlim[i+1]-rlim[i]
                #Mcolumn=0.0
                for j in range(C.shape[4]): # Along theta
                    dt=tlim[j+1]-tlim[j]
                    for k in range(C.shape[3]): # Along phi
                        dp=plim[k+1]-plim[k]
                        comp=C[0,:,0,k,j,i] # g cm^-3
                        GP=GridPoint(rmid[i],tmid[j],pmid[k],dr,dt,dp,comp)
                        GParray.append(GP)
                        if k==0.0:
                            #Mcolumn+=GP.Mtot()
                            for l in range(len(ai_array)):
                                #fsize[l,i]+=GP.Mi(l)
                                fsize[l,i]+=GP.Sigmai(l)
                #Mcolumn_array[i]=Mcolumn

            # Dividing by Mcolumn
            for i in range(fsize.shape[1]):
                for l in range(fsize.shape[0]):
                    fsize[l,i]=fsize[l,i]/Mcolumn_array[i]


            return fsize,rmidAU

        ### Concatenate fsizes and rmidAU
        fsize_1,rmidAU_1=func_fsize(1)[0],func_fsize(1)[1]
        fsize_2,rmidAU_2=func_fsize(2)[0],func_fsize(2)[1]
        fsize_tmp=np.concatenate((fsize_1,fsize_2),axis=1)
        r_array=np.concatenate((rmidAU_1,rmidAU_2))

        ''' Interpolate density profile '''
        x,y=fobj.x,fobj.y
        g2d=100.0
        g2d_array=g2d*np.ones(len(r_array))
        cs=CubicSpline(x,y)
        y_array=cs(r_array)


        ### Multiplying by 1D surface density
        #fsize=fsize_tmp*y_array
        fsize=fsize_tmp

        if visual:
            ''' Quick plot to check things out '''
            fig,(ax1,ax2)=plt.subplots(1,2,figsize=(15,5))
            for i in range(psize.shape[0]):
                if i==0:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                elif i==psize.shape[0]-1:
                    ax1.plot(r_array,fsize[i],'--',label="%.3f micron"%(psize[i,0]))
                else:
                    if i%10==0:
                        ax1.plot(r_array,fsize[i])

            density_reconstructed=np.zeros(fsize.shape[1])
            for j in range(fsize.shape[1]):
                density_reconstructed[j]=np.sum(np.reshape(fsize[:,j:j+1],fsize.shape[0]))

            ax2.plot(fobj.x,fobj.y,label='original')
            ax2.plot(r_array,density_reconstructed,'.',label='reconstructed')

            ax1.set_yscale("log")
            ax2.set_yscale("log")
            ax1.legend()
            ax2.legend()
            plt.show()

        ''' Convert to prodimopy units '''
        ai_array=(ai_array*u.micron).to(u.cm)
        r_array=(r_array*u.au).to(u.cm)


        ''' Calling prodimopy '''
        write("sdprofile.in",r_array.value,y_array*g2d,g2d_array,ai_array.value,fsize)





    ''' Set up logarithmic radial grid '''
    if not stop_after_init:
        Nxx=160
        print("Creating logarithmic grid with Nxx=%d points"%Nxx)
        r_array=np.logspace(np.log10(x.min()),np.log10(x.max()),Nxx)
    if stop_after_init:
        model=read_prodimo()
        r_array=np.reshape(model.x[:,0:1],model.x.shape[0])
    g2d_array=g2d*np.ones(len(r_array))



"""

def find_mass_temp(cprodimo):
    return cprodimo

def Lfuv(M,R,Mdot,Rin=None):

    '''
    This routine computes the FUV luminosity of the
    star.

    M: stellar mass in Msun
    R: stellar radius in Rsun
    Mdot: mass accretion rate in Msun/yr
    Rin (optional): inner radius of the accretion disk in AU.
                    The default value is Rin=5*R.

    The routine returns the FUV luminosity in Lsun.
    Recall that ProDiMo needs L_fuv/L_star, so
    do not forget to divide!
    '''

    M=M*u.Msun
    R=R*u.Rsun
    Mdot=Mdot*u.Msun/u.yr

    if Rin:
        Rin=(Rin*u.au).to(u.Rsun)
        ratio=R/Rin
    else:
        ratio=1/5.

    '''
    Derive accretion luminosity using eq.(8) of Gullbring et al. 1998
    '''
    L_acc=(c.G*M*Mdot/R*(1-ratio)).to(u.Lsun)


    ''' Computes FUV luminosity using Table 6 of Yang et al. 2012 '''
    pow=-1.670+0.836*np.log10(L_acc.value)
    L_fuv=(10**pow)*u.Lsun

    return L_fuv

def Rhill(ap,Mp,Ms):
    ap=ap*u.au
    Mp=Mp*u.Msun
    Ms=Ms*u.Msun

    Rh=ap*(Mp/(3*Ms))**(1./3)

    return Rh


def iposition(PA_disk,ri,PAi):
    '''
    This routine returns the x,y values for the position of a
    planet to be included in the MCMax3D input file such that the
    planet gets correclty positionated in the output image.

    IMPORTANT: the phi value in the Image.out file must be zero.

    PA_disk: the position angle of the disk measured from
    north to east in deg.
    ri: radial separation (projected) of the planet in AU.
    PAi: position angle (projected) of the planet in deg.
    '''

    # Poision vector of the object
    thetai=((PAi+90)*u.deg).to(u.rad).value
    posi=np.array([ri*np.cos(thetai),ri*np.sin(thetai)])

    # Rotation matrix
    theta=((PA_disk-90)*u.deg).to(u.rad).value
    M=np.array([[np.cos(theta),np.sin(theta)],[-np.sin(theta),np.cos(theta)]])

    # Clockwise rotation by PAi
    pos_rotated=np.dot(M,posi)

    # Converting to MCMax3D coordinates
    x_mcmax=-1.0*pos_rotated[1]
    y_mcmax=pos_rotated[0]

    return (x_mcmax,y_mcmax)
